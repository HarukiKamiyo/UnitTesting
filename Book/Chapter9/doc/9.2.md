# セクション 9.2 要約：モックのベスト・プラクティス

## 1. セクションの核心（Key Takeaway）

モックの使用は**統合テスト（コントローラ層）に限定**し、ドメインロジックの単体テストでは使用してはならない。また、サードパーティ製ライブラリを直接モック化せず、**自プロジェクトが所有するアダプタ（インターフェイス）を介してモック化**することで、外部仕様変更のリスクを遮断すべきである。

---

## 2. 詳細解説

### 9.2.1 モックの利用は統合テストに限定する

著者は、テストの種類によってモックの可否を明確に分けています。

- **ドメイン・モデルのテスト（単体テスト）：**
  - **モック禁止。** ビジネスロジックは外部依存を持たないよう設計されるべきであり、モックが不要なはずです。
- **コントローラのテスト（統合テスト）：**
  - **モック使用。** コントローラはドメインモデルと「管理下にない依存（プロセス外依存）」を取り持つ役割があるため、ここでモックを使用します。
- **理由（Why）：**
  - ビジネスロジック（複雑さ）と、外部とのやり取り（コミュニケーション）を分離する原則に従うため。両方の性質を持つコードは避けるべきです。

### 9.2.2 「1つのテスト・ケースには複数のモックを持たせてはならない」という誤解

「1テストクラスにつき1モック」や「モックが多いと設計が悪い」という通説を否定しています。

- **論理的根拠：**
  - 「単位（Unit）」とは「コードの単位（クラス）」ではなく**「振る舞いの単位（Behavior）」**です。
  - 1つの振る舞いが、複数の「管理下にない依存（例：メッセージバスと監査ログ）」に関わるなら、テストに複数のモックが登場するのは自然であり、問題ありません。

### 9.2.3 モックの呼び出し回数を常に確認する

メソッドが呼ばれたことだけでなく、「何回呼ばれたか（あるいは呼ばれていないか）」を厳密に検証すべきです。

- **推奨される検証：**
  - 想定する呼び出しが行われていること。
  - **想定しない呼び出しが行われていないこと。**
- **理由（Why）：**
  - 外部システムとの「後方互換性」を維持するためです。
  - 外部システムは「期待しないメッセージ」を受け取るとエラーになる可能性があります。したがって、「余計なメッセージを送っていないこと」の保証は、「正しいメッセージを送ったこと」と同じくらい重要です。

### 9.2.4 モックの対象になる型は自身のプロジェクトが所有する型のみにする

これは Steve Freeman 氏らが提唱した有名な指針です。

- **ルール：** サードパーティ製のライブラリ（外部SDKなど）を直接モックにしてはいけない。
- **アプローチ：**
  1.  外部ライブラリを隠蔽する「アダプタ（独自のインターフェイス）」を作成する。
  2.  その「アダプタ」をモックにする。
- **理由とメリット：**
  - **詳細の隠蔽：** ライブラリの複雑な仕様や技術的詳細を隠し、ドメイン固有の用語で定義できる。
  - **ライブラリ変更への防御（腐敗防止層）：** ライブラリのAPIが変わっても、修正はアダプタ内のみで済み、テストコードやドメインコードへの波及を防げる（もしライブラリを直接モックしていたら、ライブラリのバージョンアップでテストの修正が大量発生する）。
- **例外：** インメモリのデータ構造や、管理下にある依存（自前のDBへのORMなど）に関しては、あえて抽象化する必要はなく、そのまま使ってよい（9.1の議論の通り、これらはモック対象ではないため）。

---

## 3. 具体例・コードの意図

### 呼び出し回数の厳密な検証（リスト参照なし、本文解説より）

```csharp
// Moqを使用した厳密な検証の例
messageBusMock.Verify(
    x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"),
    Times.Once); // 1. 正しいメソッドが1回だけ呼ばれたことを検証

messageBusMock.VerifyNoOtherCalls(); // 2. それ以外のメソッドが一切呼ばれていないことを検証
```

- **意図：**
  - `VerifyNoOtherCalls()` を使うことで、意図しない副作用（誤ったメッセージ送信）がないことを保証しようとしています。
  - これは9.1で紹介した「スパイ（Spy）」を使うと、リスト内部の状態を見るだけで自動的に達成できることでもあります（スパイは送信された全メッセージをリストに保持するため、`Count` が1であれば、他のが送られていないことは自明になる）。

---

## 4. 重要な引用・格言

> **「モックの対象になる型は自身のプロジェクトが所有する型のみにする」**
> _( 9.2.4 見出し / Steve Freeman, Nat Pryce)_

> **「単体テストの『単体』が意味することは『1単位のコード（a unit of code）』ではなく『1単位の振る舞い（a unit of behavior）』です。」**
> _( 9.2.2 )_
> _解説：モックの数を制限しようとする誤解に対する反論。_

> **「後方互換を維持するためには、アプリケーションは外部システムが想定するメッセージを省略してはならないこと、および、外部システムが想定していないメッセージを送ってはならないことの両方を保証しなくてはなりません。」**
> _( 9.2.3 )_

---

### 編集者からの補足

このセクション9.2は、9.1の「境界で切る」という戦略を補完するものです。特に9.2.4の「所有する型のみモックせよ」は、アーキテクチャ設計（アダプターパターン/腐敗防止層）とテスト戦略が密結合していることを示しています。外部ライブラリをラップした独自インターフェイスを作ることは、コードの見通しを良くするだけでなく、テストのメンテナンス性を高めるための必須テクニックであると結論づけています。
