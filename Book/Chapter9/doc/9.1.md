# セクション 9.1 要約：モックの価値を最大限に引き出す方法

## 1. セクションの核心（Key Takeaway）

モックは、ドメインモデル内部のクラスではなく、**「アプリケーションの境界」に位置する「管理下にない依存（外部システム）」とのインターフェイスに対してのみ適用すべき**である。これにより、テストは実装詳細から切り離され、外部システムとの通信契約（コントラクト）を守るための強力な保護壁となる。

---

## 2. 詳細解説

### 9.1.1 アプリケーションの境界を超えて行われるコミュニケーションの検証

著者は、モックを適用する「場所」の選択が、テストの品質を決定づけると主張しています。

- **問題の所在：中間層のモック化**
  - 提示された例では、コントローラが `IMessageBus` というラッパークラスを経由して `IBus`（実際の外部送信部）を呼び出しています。
  - 当初のテスト（リスト 9.3）は、中間の `IMessageBus` をモック化していました。これは、`IMessageBus` という「実装の詳細」にテストが依存していることを意味します。

- **解決策：境界でのモック化**
  - モックの対象を `IMessageBus`（中間層）ではなく、**`IBus`（システムの境界）** に変更すべきです。

- **理由と根拠（Why）：**
  - **リファクタリングへの耐性の向上：** 中間クラス（`MessageBus`）はリファクタリングで構造が変わる可能性があります。境界（`IBus`）をモック化していれば、中間層の実装が変わっても、最終的に外部に送られるメッセージが同じならテストは壊れません。
  - **退行（Regression）に対する保護の強化：** 中間クラスをモックすると、「中間クラスのメソッドを呼んだこと」しか検証できません。境界をモックすれば、「実際に外部システムへ送信されるテキストメッセージの内容」まで検証できるため、保護レベルが高まります。

### 9.1.2 モックからスパイへの置き換え

境界での検証を行う際、モックフレームワークではなく「スパイ（手書きのモック）」を使用するアプローチが推奨されています。

- **スパイ（Spy）の定義：**
  - モックと同じ目的で使用されるテストダブルの一種。モックフレームワークを使わずに手書きで作成され、内部に呼び出し履歴を保持するクラスのこと。

- **スパイのメリット（vs モックフレームワーク）：**
  - **検証ロジックの再利用：** 複雑なアサーション（例：送信されたメッセージの JSON 構造の検証など）をスパイクラス内部にカプセル化できます。これにより、テストコードが読みやすくなり（Fluent Interface の実現）、複数のテストで検証ロジックを再利用できます,。
  - **「テストはプロダクションコードを信頼すべきではない」原則の遵守：**
    - 中間クラス（`MessageBus`）をモック化することは、そのクラスが正しく動くと「仮定」することと同義です。
    - スパイを使って境界（`IBus`）で検証することは、中間クラスが生成した実際の結果（メッセージ）を検査することになり、プロダクションコードの挙動を裏取りすることになります。

### 9.1.3 ログ出力の検証でもテスト・ダブルの対象を変えるべきか？

ここで著者は、メッセージバス（外部通信）とログ出力（外部出力）の扱いの違いについて議論しています。

- **議論：** `IMessageBus` と同様に、`IDomainLogger`（ラッパー）ではなく `ILogger`（境界）をモック化すべきか？
- **結論：** ログ出力に関しては、必ずしも境界（`ILogger`）をモック化する必要はなく、ラッパー（`IDomainLogger`）のモックのままで良い場合が多い。

- **理由（トレードオフ）：**
  - **メッセージバスの場合：** 外部システムとの「後方互換性」が必須であり、送信されるメッセージの構造が変わればシステムが壊れるため、厳密な境界検証が必要です。
  - **ログ出力の場合：** ログのテキスト構造が多少変わっても、システムの動作には致命的な影響を与えません（ログ監視者には重要かもしれませんが、外部 API ほど厳格な契約ではありません）。
  - **コスト対効果：** ログ出力の正確なテキスト生成まで検証するのはコストが高く、その割に得られる価値（バグ発見）が低いため、ここでは実用性を優先します。

---

## 3. 具体例・コードの意図

このセクションで提示されているコードの変化は、テスト対象の「視点」の変化を表しています。

1.  **リスト 9.3（初期のテスト）：**
    - `messageBusMock.Verify(x => x.SendEmailChangedMessage(...))`
    - **意図：** 「便利なラッパーメソッドを呼んだか？」を確認している。
    - **欠点：** ラッパーの中で何が起きているか（どんなメッセージが作られたか）は関知していない。

2.  **リスト 9.5（改善後のテスト）：**
    - `busMock.Verify(x => x.Send("Type: USER EMAIL CHANGED; ..."))`
    - **意図：** 「外部システムが受け取る最終的な文字列は何か？」を確認している。
    - **改善点：** ラッパー（`MessageBus`）の実装もテスト範囲に含まれるようになり、統合テストとしての価値が上がった。

3.  **リスト 9.6 & 9.7（スパイの導入）：**
    - `busSpy.ShouldSendNumberOfMessages(1).WithEmailChangedMessage(...)`
    - **意図：** 検証コードを「英語の文章（Fluent Interface）」のように読める形に抽象化する。
    - **改善点：** テストコードから低レベルな文字列比較ロジックを排除し、ビジネスルールの検証に集中できるようにした。

---

## 4. 重要な引用・格言

> **「モックを使うのは、アプリケーションの境界に位置する管理下にない依存が行うコミュニケーションを検証するときだけにする、という指針を常に守るようにしましょう。」** > _( 9.1.1 TIP)_

> **「テストで確認している際はプロダクション・コードを信頼すべきではないから」** > _( 9.1.2)_ > _解説：モックで中間層を置き換えることは、その中間層が正しく動作すると盲目的に信じることと同じであり、テストの信頼性を下げるという意味。_

> **「外部とのやり取りにおいて、後方互換を保てているようになります。まさに、この後方互換の保証がテストに対して求められていることであり、モックを導入する目的みなのです。」** > _( 9.1.1 TIP)_

---

### 編集者からの補足

このセクションは、単に「モックの使い方」を説いているのではなく、「**システムの境界（Boundary）をどこに定義するか**」という設計論とテスト戦略を結びつけています。「ヘキサゴナルアーキテクチャ」などの文脈において、ポート（インターフェイス）とアダプター（実装）のどこでテストを切るべきかという問いへの明確な回答となっています。

---

# 9.1 コード解説：モックの対象を「境界」へ移動させる物語

このセクションの目的は、テストの信頼性を上げるために、**「モックを差し込む場所（切断点）」を奥へ奥へと移動させること**です。

3つのステップで進化していきます。

## ステップ1：最初の状態（まだ問題がある）

**登場人物：**

1.  **コントローラ (`UserController`)**: テスト対象。
2.  **メッセージバス (`MessageBus`)**: 外部にメールを送るためのラッパークラス。
3.  **DBなど**: その他。

### リスト9.3のテスト

ここでやっているのは、**「メッセージバスそのものをモック化する」** アプローチです。

```csharp
// 意訳したコードの流れ
var messageBusMock = new Mock<IMessageBus>(); // 1. 中間層をモックにする

var sut = new UserController(..., messageBusMock.Object, ...); // 2. コントローラに渡す

sut.ChangeEmail(...); // 3. 実行

// 4. 検証：「SendEmailChangedMessage」というメソッドが呼ばれたか？
messageBusMock.Verify(x => x.SendEmailChangedMessage(...));
```

- **何が問題か？**
  - 「メソッドを呼んだか？」しかチェックしていません。
  - そのメソッドの中で、**「実際にどんな文字列（メッセージ）が組み立てられたか」は検証できていません**。
  - もし `MessageBus` クラスの実装をミスして、空っぽのメールを送るようになっていても、このテストは「成功」してしまいます。これが**「偽陽性（False Positive）」**のリスクです。

---

## ステップ2：改善案（モックの位置をずらす）

著者はここで、「`MessageBus` はまだアプリの内側だ。もっと外側の境界線で検証すべきだ」と言います。そこで登場するのが **`IBus`** です。

### リスト9.4：新しい設計

構造を以下のように変えました。

- **`IMessageBus` (アプリ固有のラッパー)**
  - ドメイン用語（`SendEmailChangedMessage`など）を話す。
  - 内部で、具体的な文字列（`"Type: USER EMAIL CHANGED..."`）を組み立てる。
  - **ここをテスト範囲に含めたい！**
- **`IBus` (システムの境界線)**
  - 単に文字列を受け取って外部に投げるだけの土管。
  - `void Send(string message)` という単純なメソッドのみ。

### リスト9.5：改善されたテスト

ここで大きな変化が起きます。**モックにする対象が `IMessageBus` から `IBus` に変わります。**

```csharp
// 意訳したコードの流れ
var busMock = new Mock<IBus>(); // 1. 【変更点】一番外側の境界をモックにする

// 2. 【重要】MessageBusは「本物（new）」を使う！
//    ただし、その中身（送信先）として上記のモックを渡す
var messageBus = new MessageBus(busMock.Object);

var sut = new UserController(..., messageBus, ...);

sut.ChangeEmail(...);

// 3. 検証：「Send」メソッドに、「正しい文字列」が渡されたか？
busMock.Verify(x => x.Send(
    "Type: USER EMAIL CHANGED; " +
    $"Id: {user.UserId}; " +
    "..."
));
```

- **何が良くなったか？**
  - `MessageBus` クラスがテストの「検証対象」に含まれました。
  - もし `MessageBus` がメッセージの組み立てをミスしたら、テストが落ちてくれます。
  - **「メソッドを呼んだか」ではなく「正しいデータが外に出ようとしたか」を検証できるようになりました。**

---

## ステップ3：スパイへの進化（読みやすさの改善）

ステップ2で正確性は上がりましたが、検証コード（`Verify` の中身）が複雑な文字列比較になり、読みづらくなりました。
そこで、汎用的なモックフレームワーク（Moqなど）を使うのをやめ、**「スパイ（手書きのモック）」**を作ります。

### リスト9.6：スパイの実装

スパイは単なる「記録係」のクラスです。

```csharp
public class BusSpy : IBus
{
    private List<string> _sentMessages = new List<string>();

    // Sendされたら、単にリストに記録するだけ
    public void Send(string message) {
        _sentMessages.Add(message);
    }

    // 検証用のメソッドを自分で作る（これが便利！）
    public BusSpy ShouldSendNumberOfMessages(int number) { ... }
    public BusSpy WithEmailChangedMessage(...) { ... }
}
```

### リスト9.7：完成形のテスト

テストコードが劇的に読みやすくなります。

```csharp
// 意訳したコードの流れ
var busSpy = new BusSpy(); // 1. スパイを作成
var messageBus = new MessageBus(busSpy); // 2. 本物のバスにスパイを仕込む

var sut = new UserController(..., messageBus, ...);

sut.ChangeEmail(...);

// 3. 検証：英語の文章のように読める（Fluent Interface）
busSpy
    .ShouldSendNumberOfMessages(1) // メッセージが1通で、
    .WithEmailChangedMessage(user.UserId, "new@gmail.com"); // 内容が正しいこと
```

- **意図とメリット**
  - 複雑な文字列比較ロジックを `BusSpy` クラスの中に隠蔽（カプセル化）しました。
  - テストコード自体は「何を確認したいか（What）」だけを語るようになり、**仕様書のように読める**ようになります。
  - **「プロダクションコード（MessageBus）を信頼せず、実際に生成された結果（文字列）をスパイで裏取り調査する」** という形が完成しました。

---

## まとめ：何が変わったのか？

| 段階          | モック対象             | テストの範囲                | 検証内容                         | 評価                                                   |
| :------------ | :--------------------- | :-------------------------- | :------------------------------- | :----------------------------------------------------- |
| **ステップ1** | `IMessageBus` (中間層) | コントローラのみ            | 「ラッパーメソッドを呼んだか？」 | **弱い**。メッセージの中身が間違っていても気づけない。 |
| **ステップ2** | `IBus` (境界)          | コントローラ + `MessageBus` | 「最終的な文字列が正しいか？」   | **強い**。リファクタリングにも強い。                   |
| **ステップ3** | `BusSpy` (手書き)      | 同上                        | 同上（記述が人間に優しい）       | **最強**。読みやすく、保守しやすい。                   |

このセクションは、単にコードを書き換えているのではなく、**「テストがシステムのどこまでを保証すべきか（＝境界まで保証すべき）」** という哲学をコードに落とし込む過程を示しています。
