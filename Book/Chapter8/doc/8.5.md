## 8.5 統合テストのベスト・プラクティス

このセクションでは、統合テストを最大限に活用し、コードベース全体の健全性を向上させるための主要なプラクティスについて解説されています。

### 8.5.1 ドメイン・モデルの境界を明確にする

ドメイン・モデル（ビジネス知識の集まり）をコードベース内の明確に分かりやすい場所に配置することが重要です。

- **利点:** 境界が明確になることで、何をテストしているのかが把握しやすくなります。
- **テストの区別:** ドメイン・ロジックを単一のグループにまとめることで、「ドメイン・モデルを検証する単体テスト」と「コントローラを検証する統合テスト」の区別が容易になります。

### 8.5.2 アプリケーションを構成する層を減らす

開発者は抽象化や汎用化のために間接参照（indirection）の層を増やしがちですが、層が重なりすぎるとコードの理解を妨げ、開発者の認知負荷を高めます。

- **推奨される構成:** バックエンド・システムであれば、以下の**3 つの層**だけで十分に構成可能です。
  1. **ドメイン層:** ビジネス・ロジックを担う。
  2. **アプリケーション・サービス層（コントローラ層）:** 外部クライアントへの露出と、ドメイン層・プロセス外依存との調整を担う。
  3. **インフラ層:** データベースのリポジトリや外部サービスのゲートウェイなど、プロセス外依存へのアクセスを可能にする。
- **テストへの影響:** 層を少なく保つことで、単体テストと統合テストの両方が作成しやすくなります。

### 8.5.3 循環依存を取り除く

循環依存（2 つ以上のクラスが互いに依存している状態）は、コードの解読を極端に難しくし、テストにも悪影響を及ぼします。

- **問題点:** 循環依存があると、1 つのクラスをテストするために別のクラスのモックが必要になるなど、テスト・ケースの作成に大きな負荷がかかります。
- **解決策:** インターフェイスを導入して依存を隠すだけでは根本的な解決になりません。ドメイン・イベントを利用するなどのリファクタリングを行い、依存の連鎖を断ち切ることで、コードを理解するための認知負荷を減らすべきです。

1. 循環依存が発生しているコード（リファクタリング前）
   以下のコードでは、2 つのクラスが互いに依存し合っています。CheckOutService が ReportGenerationService を呼び出し、処理が終わると ReportGenerationService が CheckOutService を呼び戻す（コールバックする）という構造です。

```csharp
// CheckOutService.cs
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        // 自分自身（this）を引数として渡し、コールバックを期待する
        service.GenerateReport(orderId, this);
    }

    // レポート生成完了後に呼び出されるメソッド
    public void ReportGenerated(Report report)
    {
        // 完了後の処理...
    }
}

// ReportGenerationService.cs
public class ReportGenerationService
{
    public void GenerateReport(int orderId, CheckOutService checkOutService)
    {
        // レポートの生成処理...

        // 生成が完了したら、受け取ったインスタンスのメソッドを呼び出す（循環依存）
        checkOutService.ReportGenerated(report);
    }
}
```

コードの解説と問題点
- 相互依存: CheckOutService はレポート生成のために ReportGenerationService を必要とし、逆に ReportGenerationService も完了通知のために CheckOutService を必要としています。
- 認知負荷の増大: このような構造は、コードを読み始める際にどこから手を付ければよいかが不明確になり、理解するための負担（認知負荷）を大きくします。
- インターフェイスによる「隠蔽」の罠: インターフェイスを導入してコンパイルを通るようにしても、実行時の依存関係（循環）は解消されず、むしろ構造を複雑にするだけだと指摘されています。

---

2. 循環依存を解消したコード（リファクタリング後）
   循環依存を解決する最も良い方法は、依存関係を一方通行にすることです。ここでは、コールバックを使う代わりに、メソッドが「処理結果を戻り値として返す」ように変更されています。

```csharp
// CheckOutService.cs
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        // 戻り値としてレポートを受け取る（一方通行の依存）
        Report report = service.GenerateReport(orderId);

        // 自身の中で続きの処理を行う
    }
}

// ReportGenerationService.cs
public class ReportGenerationService
{
    // CheckOutServiceへの参照を持たず、結果（Report）を返すだけにする
    public Report GenerateReport(int orderId)
    {
        // レポートの生成処理...
        return report;
    }
}
```

解決策のポイント
- 依存の単一化: ReportGenerationService は CheckOutService のことを一切知る必要がなくなり、純粋にレポートを生成して返すだけの役割になります。
- テストの容易性: 依存が一方通行になることで、それぞれのクラスを独立して理解・テストすることが容易になります。
- 結論: ソースでは、循環依存をインターフェイスで隠すのではなく、ドメイン・イベントの利用や戻り値の活用などによって、依存関係そのものを物理的に切り離すべきであると結論付けられています。

### 8.5.4 1 つのテスト・ケースに複数の実行 (Act) フェーズを用いる場合

原則として、1 つのテスト・ケースには 1 つの実行フェーズ（Act）が含まれるべきですが、例外的に複数の Act フェーズを許容する場合があります。

- **例外のケース:** プロセス外依存（外部システムなど）の状態をリセットするのに時間がかかる場合や、呼び出し回数に制限がある環境でテストを行う場合です。
- **効率化:** このような状況では、複数の実行フェーズを 1 つのテストにまとめることで、テスト全体の実行時間を短縮し、効率的に検証を行うことができます。
- **分類:** ただし、このような構成のテストは、多くの場合「統合テスト」ではなく、より大規模な「E2E テスト」に分類されます。

---

**例えるなら：**
これらのベスト・プラクティスは、**「整理整頓された職場の動線設計」**のようなものです。
ドメインの境界を明確にし、余計な層を減らすことは、道具を置く場所を決め、無駄な移動（間接参照）を省くことに相当します。循環依存を取り除くことは、作業工程が「行ったり来たり」にならないよう一方通行のフローに整えることです。これらが整うことで、どこに不具合（バグ）があるかの点検（テスト）がスムーズになり、職場全体の生産性（コードの健全性）が向上するのです。
