## 💡 7.4.2 ドメイン・モデルの状態を追跡するドメイン・イベントの利用

7.4.2項は、**ドメイン・イベント**を導入することで、ドメイン・モデルの状態変更を追跡し、**コントローラの複雑化を防ぎながら、外部システムへの連携を正確に行う**方法について解説しています。

---

### 1. ドメイン・イベントの定義と役割

* **定義:** ドメイン・イベントとは、**ドメイン・エキスパートにとって意味のあるアプリケーションのイベント**を表現するものです。これは「ボタンのクリック」のような一般的なイベントとは区別されます。
* **役割:** ドメイン・イベントは、**ドメイン・モデル内で起こった重要な状態の変更**を把握し、その変更が発生した後にプロセス外依存（データベース、メッセージバスなど）に対してその変更を伝える際に使用されます。

### 2. ドメイン・イベント導入の必要性

従来の `UserController` の実装（リスト7.11）には、以下のような欠陥がありました。

* メールアドレスの変更がなかった場合でも、メッセージバスにメール変更メッセージを**送信してしまう**（変更の有無にかかわらずメッセージを送信する処理がコントローラにある）。
* この欠陥を修正するためにコントローラに`if`文を追加すると、ビジネス・ロジックが分散し、コントローラが過度に複雑になる。

このような複雑なロジック（変更の有無の確認など）をコントローラに持ち込むのを避けるため、ドメイン・イベントを利用します。

### 3. 実装のステップ

#### ステップ A: イベントクラスの定義
* ドメイン・イベントは、発生した事実を表現するため、名前に**過去形**を用います（例: `EmailChangedEvent`）。
* イベント・オブジェクトは**不変（Immutable）**であり、値として扱われます。
* このユースケースでは、新しいメールアドレスとユーザーIDを保持する `EmailChangedEvent` クラスを定義します。

#### ステップ B: ドメイン・モデル（Userクラス）の修正
* `User`クラスに、発生したドメイン・イベントを格納するためのコレクション（例: `List<EmailChangedEvent> EmailChangedEvents`）を追加します。
* `ChangeEmail`メソッド内で実際にメールアドレスが変更されたとき（`Email = newEmail`の行の後）に、このイベント・コレクションに`EmailChangedEvent`のインスタンスを**追加**します。
* これにより、**データベースへの保存ロジック**と、**メッセージの送信ロジック**がドメイン・イベントの有無によって分離されます。

#### ステップ C: コントローラ（UserController）の修正
* `UserController.ChangeEmail`メソッドにおいて、データの永続化（`_database.SaveUser(user)`）を行った後、**`User`クラスの`EmailChangedEvents`コレクションを反復処理**します（リスト7.13）。
* コレクション内のドメイン・イベントを取得し、それをメッセージに変換してメッセージバスに送信します。

### 4. ドメイン・イベント導入のメリット

* **コントローラの簡潔さの維持:** コントローラは、メールアドレスが変更されたか否かを判断するロジック（`if`文）を持つ必要がなくなります。これは、イベントが生成されたかどうかに基づいて処理を進めるからです。
* **ドメイン・モデルのテスト容易性の向上（単体テスト）:**
    * ドメイン・モデルの単体テストにおいて、外部依存（メッセージバス）をモック化する必要がなくなります。
    * テスト対象の操作の結果として、「**特定のドメイン・イベントが生成されたこと**」を`User`オブジェクトのイベントコレクションを検証するだけで確認できるようになります（リスト7.14）。

> **結果:** ドメイン・イベントを導入することで、**コントローラから決定を下す責務**を抽出し、その責務をドメイン・モデルに担わせることが可能になり、単体テストはより簡単なものになります。