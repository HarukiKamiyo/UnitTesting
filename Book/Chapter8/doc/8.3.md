## 8.3 どのように統合 (integration) テストを行うのか？

このセクションでは、第 7 章で扱った「ユーザ管理システム」を例に、具体的な統合テストの実施方法を解説しています。このシステムは、データベースから情報を取得し、ドメイン・モデルで意思決定を行い、その結果を**データベースに保存**して**メッセージ・バスへ通知**するというプロセスを辿ります。

#### リスト 8.1 ユーザ管理システムのコントローラ

このクラスは、データベース（管理下にある依存）とメッセージ・バス（管理下にない依存）を調整する役割を担っています。

```csharp
public class UserController
{
    // プロセス外依存の定義
    private readonly Database _database = new Database();
    private readonly MessageBus _messageBus = new MessageBus();

    public string ChangeEmail(int userId, string newEmail)
    {
        // 1. データベースからユーザ情報を取得し、ドメイン・オブジェクトを復元する
        object[] userData = _database.GetUserById(userId);
        User user = UserFactory.Create(userData);

        // 2. 事前条件の確認（早期失敗プロトコルの適用）
        string error = user.CanChangeEmail();
        if (error != null)
            return error;

        // 3. データベースから会社情報を取得
        object[] companyData = _database.GetCompany();
        Company company = CompanyFactory.Create(companyData);

        // 4. ドメイン・モデルによるビジネス・ロジックの実行
        // ここでユーザの状態変更や従業員数の更新が行われる
        user.ChangeEmail(newEmail, company);

        // 5. 最終的な状態をデータベース（管理下にある依存）に保存する
        _database.SaveCompany(company);
        _database.SaveUser(user);

        // 6. メッセージ・バス（管理下にない依存）へ通知を送る
        // 外部システムが観察する「振る舞い」となるため、モックでの検証対象となる
        foreach (EmailChangedEvent ev in user.EmailChangedEvents)
        {
            _messageBus.SendMessageChangedMessage(ev.UserId, ev.NewEmail);
        }

        return "OK";
    }
}
```

---

### 8.3.1 今回テストするシナリオ

統合テストの基本的な指針は、**ビジネス・シナリオごとに 1 件のハッピー・パス**を確認し、単体テストで検証できない**異常ケース（edge case）をすべて網羅する**ことです。
今回の例では、以下のハッピー・パスを検証対象としています。

- **シナリオ:** ユーザのメール・アドレスを、自社のドメイン名を持つものから外部ドメインのものに変更する。
- **副作用:** データベース内のユーザ情報と会社情報（従業員数）が更新され、メッセージ・バスに通知が送られる。

なお、「早期失敗 (Fail Fast)」の原則により、プログラムが異常時に即座に停止するよう設計されている場合、その異常ケースをわざわざ統合テストで検証する必要はありません。

### 8.3.2 モックに置き換えるべきか否かの依存の分類

テストを作成する前に、プロセス外依存を分類します。

- **データベース:** このシステム専用であり、他のアプリからアクセスされないため、**「管理下にある依存」**と見なします。したがって、統合テストでは**実物のインスタンス**を使用し、最終的な状態を検証します。
- **メッセージ・バス:** 外部システムとの通信を目的とするため、**「管理下にない依存」**です。外部から観察可能な振る舞いを確認する必要があるため、**モックに置き換えて**対話を検証します。

### 8.3.3 E2E (End-to-End) テストはどうするのか？

統合テストと E2E テストの大きな違いは、**テストを実行するプロセス**にあります。

- **統合テスト:** テスト・ランナーと同じプロセス内でアプリケーションをホストし、管理下にない依存（メッセージ・バスなど）のみをモックにします。
- **E2E テスト:** 完全にデプロイされた状態のアプリケーションに対し、外部クライアントとして API などを介してテストを行います。この場合、すべてのプロセス外依存が実物（またはその環境用の実物）となりますが、管理下にない依存についてはやはりモックが使われることが一般的です。

統合テストで十分な保護が得られているなら、E2E テストは少数の主要なケースに絞った「スモーク・テスト」として利用するのが効率的です。

### 8.3.4 統合テストの作成

実際のテスト・コードの構成（リスト 8.2）では、以下の手順で検証を行います。

1. **準備 (Arrange):** データベースのセットアップと、メッセージ・バスのモック作成を行います。
2. **実行 (Act):** コントローラのメソッドを呼び出します。
3. **確認 (Assert):**
   - データベースから**再度データを読み込み**、ユーザと会社の状態が意図通りに変更されているか検証します。
   - メッセージ・バスのモックに対し、正しいメッセージが送信されたかを確認します。

特に、**データベースの状態を検証する際に「入力に使った値」をそのまま使わず、改めて DB から読み直すこと**が、より強力な退行に対する保護につながります。

#### リスト 8.2 最初のバージョンの統合テスト

このテストは、実際のデータベースを使用し、メッセージ・バスのみをモックに置き換えて、ハッピー・パスを検証します。

```csharp
// シナリオ: メール・アドレスを従業員（自社ドメイン）から非従業員（一般ドメイン）に変更する
[Fact]
public void Changing_email_from_corporate_to_non_corporate()
{
    // --- 準備 (Arrange) ---
    // 管理下にある依存であるデータベースは実物のインスタンスを使用する
    var db = new Database(ConnectionString);

    // ヘルパー・メソッドを使用して、テストに必要な初期データをDBに直接保存する
    User user = CreateUser("user@mycorp.com", UserType.Employee, db);
    CreateCompany("mycorp.com", 1, db);

    // 管理下にない依存（メッセージ・バス）は、外部との対話を検証するためにモックにする
    var messageBusMock = new Mock<IMessageBus>();

    // テスト対象 (SUT) の初期化
    var sut = new UserController(db, messageBusMock.Object);

    // --- 実行 (Act) ---
    string result = sut.ChangeEmail(user.UserId, "new@gmail.com");

    // --- 確認 (Assert) ---
    Assert.Equal("OK", result);

    // 【重要】入力に使った値を信じるのではなく、DBから最新の状態を読み直して検証する
    // これにより、データベースへの保存処理が正しく行われたことを確実に保護できる
    object[] userData = db.GetUserById(user.UserId);
    User userFromDb = UserFactory.Create(userData);
    Assert.Equal("new@gmail.com", userFromDb.Email); // メールが更新されているか
    Assert.Equal(UserType.Customer, userFromDb.Type); // ユーザの種類が変わっているか

    // 会社の状態（従業員数）もDBから読み直して検証する
    object[] companyData = db.GetCompany();
    Company companyFromDb = CompanyFactory.Create(companyData);
    Assert.Equal(0, companyFromDb.NumberOfEmployees); // 従業員数が正しく減っているか

    // 外部システム（メッセージ・バス）に対して、正しいメッセージが1回だけ送られたかを検証
    messageBusMock.Verify(
        x => x.SendEmailChangedMessage(user.UserId, "new@gmail.com"),
        Times.Once);
}
```

**補足:**

- **リスト 8.1** では、ビジネス・ロジック自体は `User` ドメイン・モデルに任せ、コントローラは「依存先とのデータのやり取り」に集中しています。
- **リスト 8.2** の検証（Assert）フェーズで、`db.GetUserById` などを通じて**改めてデータを取得している**のは、メモリ上の状態ではなく「永続化された結果」を保証するためです。
