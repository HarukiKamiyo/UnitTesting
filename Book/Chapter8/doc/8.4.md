## 8.4 インターフェイスを使った依存の抽象化

このセクションでは、単体テストや統合テストにおいて誤解されがちな**「インターフェイスの利用目的」**について、本来の役割と適切な使い分けを解説しています。

### 8.4.1 インターフェイスと疎結合の関係

多くの開発者は、実装クラスが 1 つしかなくても「疎結合にするため」や「将来の拡張性（開放/閉鎖原則：OCP）のため」という理由でインターフェイスを導入しますが、ソースはこれを**間違いである**と指摘しています。

- **抽象化の欠如:** 実装が 1 つしかないインターフェイスは抽象ではありません。単なる「発見」された実装の一部に過ぎません。
- **YAGNI 原則への違反:** 「将来必要になるかもしれない」という理由でインターフェイスを導入することは、**YAGNI (You Aren't Gonna Need It)** 原則に反します。不要なコードは保守コストを上げ、コードベースの解読を難しくする「ノイズ」となります。

### 8.4.2 なぜ、プロセス外依存にインターフェイスを使うのか？

実装クラスが 1 つしかないにもかかわらず、プロセス外依存に対してインターフェイスを使う唯一の正当な理由は、**「モックを作成するため」**です。

- **テスト・ダブルの導入:** インターフェイスがないと、テスト時に依存先をテスト・ダブル（モック）に置き換えることができず、外部システムとのやり取りを検証できなくなります。
- **使い分けの基準:**
  - **管理下にない依存 (Unmanaged Dependency):** 外部システムとの対話をモックで検証する必要があるため、インターフェイスを用意します。
  - **管理下にある依存 (Managed Dependency):** データベースなどのように実物を使うべき依存先については、インターフェイスを作らず、**具象クラスを直接使用する**のが適切です。

### 8.4.3 同一プロセス内の依存に対するインターフェイス

ドメイン・クラス間（同一プロセス内）の依存に対して、テストでモックに置き換えるためだけにインターフェイスを導入することは、避けるべきです。

- **脆弱なテストの原因:** ドメイン・クラス間のやり取りをモックで検証しようとすると、実装の詳細に依存した「壊れやすいテスト」になります。
- **リファクタリングへの耐性:** ドメイン・モデル内の対話はインターフェイスで抽象化せず、その振る舞いの結果（最終的な状態の変化）を検証すべきです。そうすることで、内部構造を変更してもテストが壊れない「リファクタリングへの耐性」を維持できます。
