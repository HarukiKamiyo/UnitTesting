## 8.6 ログ出力に対するテスト

ログ出力は、テストすべきかどうかが判断しにくい複雑なトピックです。本セクションでは、ログ出力を「副作用」としてどう扱うべきかを解説します。

### 8.6.1 そもそも、ログ出力をテストすべきか？

ログ出力は、その目的によって 2 種類に分類されます。

1. **サポート・ログ:** システムの管理者やサポート・スタッフが、システムの重要なイベントを確認するためのログ。これは**「観察可能な振る舞い」**であり、テストの対象となります。
2. **診断ログ:** 開発者がデバッグのために使用するログ。これは**「実装の詳細」**であり、テストすべきではありません。

以下のコードは、ドメイン・モデル内にこれら 2 つのログが混在している例です。

#### リスト 8.3: User クラスで使われるログ出力

```csharp
public class User
{
    public void ChangeEmail(string newEmail, Company company)
    {
        // 診断ログ：メソッドの開始を示す（テスト不要）
        _logger.Info($"Changing email for user {UserId} to {newEmail}");

        Precondition.Requires(CanChangeEmail() == null);

        if (Email == newEmail)
            return;

        UserType newType = company.IsEmailCorporate(newEmail)
            ? UserType.Employee
            : UserType.Customer;

        if (Type != newType)
        {
            int delta = newType == UserType.Employee ? 1 : -1;
            company.ChangeNumberOfEmployees(delta);

            // サポート・ログ：ビジネス上の重要な変化を記録（テスト対象）
            _logger.Info($"User {UserId} changed type from {Type} to {newType}");
        }

        Email = newEmail;
        Type = newType;
        EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));

        // 診断ログ：メソッドの終了を示す（テスト不要）
        _logger.Info($"Email is changed for user {UserId}");
    }
}
```

**解説:** このコードでは、ビジネス上の重要な変更（ユーザーの種類の変更）を記録するログと、単なる処理の経過を追うログが同じ `_logger` で出力されており、テストすべき境界が曖昧になっています。

---

### 8.6.2 どのようにログ出力をテストすべきか？

ログ出力は、プロセス外のストレージ（ファイル、データベースなど）に対して副作用を発生させる行為です。そのため、テストにおいては他のプロセス外依存と同様に、**モックを使用してアプリケーションとログ・ストレージ間のやり取りを検証する**必要があります。

しかし、単体テストを「リファクタリングへの耐性」がある価値の高いものにするためには、単に `ILogger` のような汎用インターフェイスをモックにするのではなく、以下の段階を踏んでリファクタリングとテスト設計を行うことが推奨されています。

---

#### 1. ビジネス要求に応じたログ出力オブジェクト（IDomainLogger）の導入

まず、管理者やサポート担当者が利用する**「サポート・ログ」**を、開発者向けの「診断ログ」から分離します。そのためには、ビジネス要求をメソッドとして定義した**専用のインターフェイス**を作成します。

これにより、テスト・コードで「特定の文字列が出力されたか」を検証するのではなく、「特定のビジネス・イベントが発生したか」を確認できるようになります。

**リスト 8.4: DomainLogger を介してサポート・ログを出力するようにした User クラス**

```csharp
public void ChangeEmail(string newEmail, Company company)
{
    // 診断ログ：開発者向けのデバッグ情報。汎用 ILogger を使用（テスト不要）
    _logger.Info($"Changing email for user {UserId} to {newEmail}");

    Precondition.Requires(CanChangeEmail() == null);

    if (Email == newEmail)
        return;

    UserType newType = company.IsEmailCorporate(newEmail)
        ? UserType.Employee
        : UserType.Customer;

    if (Type != newType)
    {
        int delta = newType == UserType.Employee ? 1 : -1;
        company.ChangeNumberOfEmployees(delta);

        // サポート・ログ：ビジネス上の重要な変更を、専用インターフェイスを介して出力
        // これがテスト対象となる
        _domainLogger.UserTypeHasChanged(UserId, Type, newType);
    }

    Email = newEmail;
    Type = newType;
    EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));

    // 診断ログ（テスト不要）
    _logger.Info($"Email is changed for user {UserId}");
}
```

**リスト 8.5: DomainLogger インターフェイスの実装クラス**

```csharp
public class DomainLogger : IDomainLogger
{
    private readonly ILogger _logger;

    public DomainLogger(ILogger logger)
    {
        _logger = logger;
    }

    public void UserTypeHasChanged(int userId, UserType oldType, UserType newType)
    {
        // ログのフォーマットをここで一括管理する
        _logger.Info($"User {userId} changed type from {oldType} to {newType}");
    }
}
```

---

#### 2. 構造化ログ（Structured Logging）の活用

リスト 8.5 で導入された `DomainLogger` は、**構造化ログ**の概念を取り入れています。構造化ログとは、ログ・データの「生成」とその「出力形式」を切り離す手法です。

- **従来の手法:** 単純なテキストとしてメッセージを出力するため、後から解析（集計など）を行うのが困難でした。
- **構造化ログ:** メッセージ・テンプレート（`User {userId}...`）とパラメータ（`userId`）を分けて保持します。これにより、後から同じデータを JSON、CSV、あるいは検索可能なデータベース形式など、**用途に合わせて最適な形式に変換して出力**することが可能になります。

---

#### 3. ドメイン・イベントによるプロセス外依存の完全な排除

リスト 8.4 の時点では、まだ `User` クラスが `IDomainLogger` というプロセス外依存を直接扱っています。これは、ビジネス・ロジックにプロセス外依存との通信責任が混ざっていることを意味し、テストの複雑さを招きます。

これを解決するため、**ドメイン・イベント**を導入し、ログ出力をドメイン・モデルの外部（コントローラ）へ押し出します。

**リスト 8.6: DomainLogger の呼び出しをドメイン・イベントに置き換えた User クラス**

```csharp
if (Type != newType)
{
    int delta = newType == UserType.Employee ? 1 : -1;
    company.ChangeNumberOfEmployees(delta);

    // ログを出力する代わりに、ビジネス・イベントを記録する
    AddDomainEvent(new UserTypeChangedEvent(UserId, Type, newType));
}
```

このリファクタリングにより、`User` クラス（ドメイン・モデル）はログ出力という副作用を直接実行しなくなり、テストが極めて容易になります。

**リスト 8.7: ドメイン・イベントを処理するように修正された UserController**

```csharp
public string ChangeEmail(int userId, string newEmail)
{
    // ...準備フェーズ...
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    // ...中略...

    // 実行フェーズ
    user.ChangeEmail(newEmail, company);

    // 保存フェーズ
    _database.SaveCompany(company);
    _database.SaveUser(user);

    // ドメイン・イベントをディスパッチ（配信）し、
    // ここで対応するロガーが呼び出される
    _eventDispatcher.Dispatch(user.DomainEvents);

    return "OK";
}
```

#### テストにおける検証のポイント

この構成にすることで、検証は以下のように整理されます：

- **単体テスト:** `User` クラスが特定の条件で正しく `UserTypeChangedEvent` インスタンスを生成したかを検証します。
- **統合テスト:** モック化した `IDomainLogger` を用い、コントローラがイベントを受け取った際に、モックのメソッドが適切に呼び出されたか（対話）を検証します。

このように、ログ出力を単なる「文字列の出力」としてではなく、**「外部から観察可能なビジネス・イベントの報告」**として扱うことで、保守性の高いテストを実現できます。

---

### 8.6.3 どのくらいのログを出力すれば十分なのか？

診断ログの過剰な出力は避けるべきです。理由は以下の 2 点です。

- **プロダクション・コードの汚染:** ログ出力コードが散らばると、ビジネス・ロジックが読みづらくなります。
- **ノイズの増大:** ログが多すぎると、重要な情報を見つけるのが難しくなります（信号対雑音比の低下）。

ドメインモデルでは、診断ログをまったく出力させないのが理想。

---

### 8.6.4 ロガーを静的フィールドで保持する動機とその問題点

ソースでは、ロガーを静的なフィールドとして保持し、クラス内部から直接アクセスできるようにする手法を**「環境コンテキスト (ambient context)」**と呼んでいます。リスト 8.8 に示されているような実装がこれに該当します。

#### 1. なぜ静的フィールドで保持しようとするのか（動機）

開発者がロガーを静的フィールド（`private static readonly ILogger _logger = ...`）として定義したくなる主な動機は、**「利便性」と「コードの簡潔さ」**にあります。

- **依存関係の受け渡しが面倒:** アプリケーションが大規模になり、多くのドメイン・クラスでログ出力が必要になった場合、そのすべてのクラスのコンストラクタやメソッドにロガーを明示的に追加していく作業は非常に手間がかかります。
- **間接参照（indirection）の層を増やしたくない:** セクション 8.5.2 で述べたように、層が重なりすぎることは認知負荷を高めます。ロガーをすべての層でバケツリレーのように引き渡していくことは、コードを複雑にしているように感じられるため、どこからでも呼べる「静的な場所」に置きたくなる誘惑が生じます。
- **パフォーマンスへの懸念:** ソースでは、明示的な受け渡しが難しい場合に、性能面での理由から環境コンテキストから取得する方法が検討される可能性についても言及されています。

#### 2. リスト 8.8：アンチパターンの例

静的なメソッド（`LogManager.GetLogger`）を介してロガーを取得し、プライベートな静的フィールドに格納する典型的な実装例です。

```csharp
public class User
{
    // 静的なメソッドを介してロガーを取得し、フィールドに保持する
    private static readonly ILogger _logger = LogManager.GetLogger(typeof(User));

    public void ChangeEmail(string newEmail, Company company)
    {
        // どこからでもこのロガーを呼び出せてしまう
        _logger.Info($"Changing email for user {UserId} to {newEmail}");
        // ...
    }
}
```

#### 3. なぜアンチパターンなのか？

書籍はこの手法を明確に否定しています。その理由は、**「依存関係が隠れてしまう」**からです。

- **テストが困難になる:** ロガーがクラスの内部で静的に固定されていると、テストの際にそのロガーをモックに差し替えることが非常に難しくなります。その結果、テストの実行時に実際のファイルやストレージにログが書き込まれてしまったり、ログ出力の検証ができなくなったりします。
- **リファクタリングへの耐性が下がる:** 依存関係がコンストラクタなどの「シグネチャ」に現れないため、コードを読んでもそのクラスが何に依存しているのかが即座に理解できず、認知負荷を下げることができません。

#### 4. 推奨される解決策（リスト 8.9）

ソースが提示する解決策は、手間がかかっても**「明示的に注入する」**ことです。

```csharp
public void ChangeEmail(string newEmail, Company company, ILogger logger)
{
    // 引数として明示的に受け取ったロガーを使用する
    logger.Info($"Changing email for user {UserId} to {newEmail}");
    // ...
}
```

このように、メソッドの引数やコンストラクタを通じてロガーを渡すことで、テスト時には簡単にモックを注入できるようになり、コードの透明性も確保されます。

---

**解説:** ログ出力オブジェクトも他の依存先と同様に、**コンストラクタやメソッドの引数を通じて明示的に注入**すべきです。これにより、テストの制御が容易になり、依存関係が明確になります。
