## 8.5 統合テストのベスト・プラクティス

このセクションでは、統合テストを最大限に活用し、コードベース全体の健全性を向上させるための主要なプラクティスについて解説されています。

### 8.5.1 ドメイン・モデルの境界を明確にする

ドメイン・モデル（ビジネス知識の集まり）をコードベース内の明確に分かりやすい場所に配置することが重要です。

- **利点:** 境界が明確になることで、何をテストしているのかが把握しやすくなります。
- **テストの区別:** ドメイン・ロジックを単一のグループにまとめることで、「ドメイン・モデルを検証する単体テスト」と「コントローラを検証する統合テスト」の区別が容易になります。

### 8.5.2 アプリケーションを構成する層を減らす

開発者は抽象化や汎用化のために間接参照（indirection）の層を増やしがちですが、層が重なりすぎるとコードの理解を妨げ、開発者の認知負荷を高めます。

- **推奨される構成:** バックエンド・システムであれば、以下の**3 つの層**だけで十分に構成可能です。
  1. **ドメイン層:** ビジネス・ロジックを担う。
  2. **アプリケーション・サービス層（コントローラ層）:** 外部クライアントへの露出と、ドメイン層・プロセス外依存との調整を担う。
  3. **インフラ層:** データベースのリポジトリや外部サービスのゲートウェイなど、プロセス外依存へのアクセスを可能にする。
- **テストへの影響:** 層を少なく保つことで、単体テストと統合テストの両方が作成しやすくなります。

ソースに基づき、**8.5.3「循環依存を取り除く」**の内容について、コードの実装詳細と設計上の意図を深く掘り下げて解説します。

### 8.5.3 循環依存を取り除く

**循環依存（circular dependency）**とは、2 つ以上のクラスが直接的、あるいは間接的にお互いに依存し合っている状態を指します。このような依存関係は、コードの理解を著しく困難にするだけでなく、テストの作成においても大きな障害となります。

#### 1. 循環依存の典型例：コールバック・パターン

ソースでは、循環依存のよくある例として**コールバック**を用いた設計が挙げられています。

**リファクタリング前のコード（コールバックによる相互依存）**

```csharp
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        // 自身のインスタンス(this)を引数として渡す
        service.GenerateReport(orderId, this);
    }

    // レポート生成完了後に呼び出されるメソッド
    public void ReportGenerated(Report report)
    {
        // 完了後の処理...
    }
}

public class ReportGenerationService
{
    public void GenerateReport(int orderId, CheckOutService checkOutService)
    {
        // レポートの生成処理...
        // ...
        // 処理が終わったら、受け取ったインスタンスのメソッドを呼び出す
        checkOutService.ReportGenerated(report);
    }
}
```

- **構造の問題:** `CheckOutService` はレポート生成のために `ReportGenerationService` を作成しますが、呼び出される側の `ReportGenerationService` もまた、完了通知のために `CheckOutService` を知っている必要があります。
- **認知負荷の増大:** このような設計では、コードを読み進める際に「どこから読み始めればよいか」が不明確になります。たとえ個々のクラスが小さくても、お互いに依存し合っていると、それらを**一塊の巨大なコードとして理解せざるを得なくなり**、開発者の脳に過度な負担（認知負荷）を与えます。

#### 2. インターフェイスによる「隠蔽」の罠

この循環依存を解消しようとして、安易にインターフェイスを導入することは推奨されません。例えば、`ICheckOutService` を作成して `ReportGenerationService` に渡すように変更したとしても、それは単に**コンパイル上の問題を回避しただけに過ぎません**。

- **実行時の実態:** ソース内の図 8.11 が示す通り、インターフェイスを導入しても実行時の物理的な依存関係（循環）は残ったままです。
- **複雑性の増加:** むしろ、解決すべき問題（循環依存）がインターフェイスの背後に隠れて見えにくくなり、構造をより複雑にする「ノイズ」となってしまいます。

#### 3. 解決策：依存関係の一方通行化

循環依存を根本的に解決する最善の方法は、依存関係を**一方通行（one-way）**にすることです。ソースでは、コールバックの代わりに「メソッドの戻り値」を利用する方法を提示しています。

**リファクタリング後のコード（戻り値による一方通行化）**

```csharp
public class CheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        // 自身の参照を渡すのではなく、結果を戻り値として受け取る
        Report report = service.GenerateReport(orderId);

        // 戻り値を受け取った後、自身のメソッドを呼ぶなどの処理を続ける
    }
}

public class ReportGenerationService
{
    // CheckOutService の存在を一切知らない
    public Report GenerateReport(int orderId)
    {
        // レポートの生成処理...
        return report; // 生成したレポートを返すだけ
    }
}
```

- **依存の単一化:** `ReportGenerationService` は `CheckOutService` のことを一切知る必要がなくなり、純粋にレポートを生成して返すだけの役割に専念できます。
- **テストの容易性:** 依存が一方通行になることで、各クラスを独立してテストすることが容易になります。テストのために相手側の複雑なモックを用意する必要がなくなるため、テスト・ケースの作成負荷が大幅に軽減されます。

**結論:**
価値の高い統合テストを維持するためには、インターフェイスで依存を「隠す」のではなく、**ドメイン・イベントの利用や戻り値の活用**によって、依存関係を物理的に切り離すべきです。

---

**例えるなら：**
循環依存は、**「お互いの尻尾を追いかけ回している 2 匹の犬」**のようなものです。どちらが主導権を握っているのか分からず、見ている方は目が回ってしまいます。リファクタリングによって一方通行にするということは、この関係を**「バトンを渡すリレー走者」**に変えることです。前の走者はバトンを渡すだけで、後ろの走者がその後どう走るかを知る必要はありません。こうすることで、各走者（クラス）の役割が明確になり、全体の流れが把握しやすくなるのです。

### 8.5.4 1 つのテスト・ケースに複数の実行 (Act) フェーズを用いる場合

原則として、1 つのテスト・ケースには 1 つの実行フェーズ（Act）が含まれるべきですが、例外的に複数の Act フェーズを許容する場合があります。

- **例外のケース:** プロセス外依存（外部システムなど）の状態をリセットするのに時間がかかる場合や、呼び出し回数に制限がある環境でテストを行う場合です。
- **効率化:** このような状況では、複数の実行フェーズを 1 つのテストにまとめることで、テスト全体の実行時間を短縮し、効率的に検証を行うことができます。
- **分類:** ただし、このような構成のテストは、多くの場合「統合テスト」ではなく、より大規模な「E2E テスト」に分類されます。

---

#### おまけ

Q. インターフェイスを用いて隠蔽するってどういうイメージ？

A. 以下、回答。

「インターフェイスを導入して依存関係を隠蔽する」という変更は、多くの場合、**「コンパイルを通すためだけに、見た目上の依存をインターフェイスに置き換える」**という手法を指します。

循環依存が発生しているとき、そのままではコードが複雑すぎて読めなかったり、テストが書きづらかったりします。そこで「片方をインターフェイスにすれば、直接そのクラスを知らなくて済むから解決だ」と考えてしまうのが、ソースで指摘されている「罠」です。

具体的にどのようなコード変更になるのか、リファクタリング前と、インターフェイスで隠蔽した（良くない）例を比較して解説します。

### インターフェイスを作成して「隠蔽」した状態（アンチパターン）

ここで「`ReportGenerationService` が `CheckOutService` という具体的なクラスを知っているからいけないんだ。インターフェイスで隠そう」と考え、以下のように変更します。これがソースで指摘されている**「インターフェイスによる隠蔽の罠」**です。

```csharp
// 新しくインターフェイスを作る
public interface ICheckOutService
{
    void ReportGenerated(Report report);
}

// CheckOutService はインターフェイスを実装する
public class CheckOutService : ICheckOutService
{
    public void CheckOut(int orderId)
    {
        var service = new ReportGenerationService();
        service.GenerateReport(orderId, this);
    }

    public void ReportGenerated(Report report) { /* ... */ }
}

// ReportGenerationService は「具体的なクラス」ではなく「インターフェイス」に依存する
public class ReportGenerationService
{
    // CheckOutServiceクラスではなく、ICheckOutServiceインターフェイスを受け取る
    public void GenerateReport(int orderId, ICheckOutService service)
    {
        // ...処理...
        service.ReportGenerated(report);
    }
}
```

### なぜこれが「いまいち」なのか？（ソースの指摘）

この変更を行うと、確かに `ReportGenerationService` は `CheckOutService` という特定のクラス名をコードから消すことができます。しかし、ソースは以下の理由でこれを否定しています。

- **実行時の循環は消えていない:** ソース内の図 8.11 が示す通り、メモリ上（実行時）では、依然として 2 つのオブジェクトがお互いを参照し合う「循環」は残ったままです。
- **認知負荷の増大:** インターフェイスが追加されたことで、追わなければならないファイル数が増え、コードの理解を助けるどころか、むしろ構造を複雑にする「ノイズ」が増えただけになってしまいます。
- **根本解決ではない:** インターフェイスで「隠す」ことは、問題（循環依存）を物理的に切り離したことにはなりません。
